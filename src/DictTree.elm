module DictTree
    exposing
        ( Tree(..)
        , Forest
        , datum
        , children
        , singular
        , map
        , get
        , getPath
        -- , mapListOverTree
        -- , indexedMap
        , filter
        , filterWithChildPrecedence
        , flatten
        -- , tuplesOfDatumAndFlatChildren
        , foldr
        , foldl
        , length
        , addChild
        , sortBy
        , sortWith
        )

{-| A library for constructing multi-way trees. Each Tree carries two pieces of
information, it's datum and children.


# Types
@docs Tree, Forest

# Operations
@docs datum, children, foldl, foldr, flatten, tuplesOfDatumAndFlatChildren, filter, filterWithChildPrecedence, length, addChild

# Mapping
@docs map, mapListOverTree, indexedMap

# Sorting
@docs sortBy, sortWith
-}

-- todo: actually learn Elm

import Dict exposing (Dict(..))
import List
import MultiwayTree as T -- generated by sorting a DictTree
import Tuple exposing (first, second)

(&>) = flip Maybe.andThen

{-| A type to keep track of datum and children.
-}
type Tree comparable b
    = Tree b (Forest comparable b)


{-| A dict of Trees. Convenient for describing children.
-}
type alias Forest comparable b =
    Dict comparable (Tree comparable b)


{-| Access the datum of the current tree
-}
datum : Tree comparable b -> b
datum (Tree v children) =
    v

{-| A tree consisting of just one datum
-}
singular : b -> Tree comparable b
singular datum =
    Tree datum Dict.empty

{-| Access a child node
-}

get : comparable -> Tree comparable b -> Maybe (Tree comparable b)
get key (Tree _ children) =
    Dict.get key children

{-| Access a grandchild-or-whatever node by key list
-}

getPath : List comparable -> Tree comparable b -> Maybe (Tree comparable b)
getPath keys tree =
    case keys of
        [] ->
            Just tree
        key :: rest ->
            (Dict.get key <| children tree) &> getPath rest


{-| Access the children of the current tree
-}
children : Tree comparable b -> Forest comparable b
children (Tree v children) =
    children


{-| Inserts a Tree as one child of another Tree
-}
addChild : comparable -> Tree comparable b -> Tree comparable b -> Tree comparable b
addChild nk nv (Tree v children) =
    Tree v (Dict.insert nk nv children)


{-| Reduce a Tree from the left.
-}
foldl : (v -> b -> b) -> b -> Tree comparable v -> b
foldl f accu (Tree datum children) =
    let
        treeUnwrap k_ (Tree datum_ children_) accu_ =
            Dict.foldl treeUnwrap (f datum_ accu_) children_
    in
        Dict.foldl treeUnwrap (f datum accu) children


{-| Reduce a Tree from the right.
-}
foldr : (v -> b -> b) -> b -> Tree comparable v -> b
foldr f accu (Tree datum children) =
    let
        treeUnwrap k_ (Tree datum_ children_) accu_ =
            f datum_ (Dict.foldr treeUnwrap accu_ children_)
    in
        f datum (Dict.foldr treeUnwrap accu children)


{-| Flattens a Tree into a List where the root is the first element of that list.
-}
flatten : Tree comparable b -> List b
flatten tree =
    foldr (::) [] tree


-- {-| A special version of flatten which flattens a Tree into a List of Tuples like (element, [all elements in subtree])
-- 
--     (Tree.tuplesOfDatumAndFlatChildren
--         Tree "a"
--             Dict.fromList([("bk", Tree "b" Dict.empty
--             ),("ck", Tree "c" Dict.empty
--             ),("dk", Tree "d" Dict.empty
--             )])
--     == [ ( "a", [ "b", "c", "d" ] ), ( "b", [] ), ( "c", [] ), ( "d", [] ) ]
-- -}
-- tuplesOfDatumAndFlatChildren : Tree comparable b -> List ( b, List b )
-- tuplesOfDatumAndFlatChildren (Tree datum children) =
--     [ ( datum, List.concatMap flatten (Dict.values children) ) ] ++ (List.concatMap tuplesOfDatumAndFlatChildren children)
-- 

{-| Return the length of the Tree. Calculated recusively as datum (1) + length of children (n)
    Since a DictTree is never empty this function will never return Int < 1.
-}
length : Tree comparable a -> Int
length tree =
    foldr (\_ accu -> accu + 1) 0 tree


{-| Map over the DictTree
-}
map : (a -> b) -> Tree comparable a -> Tree comparable b
map fn (Tree datum children) =
    let
        mappedDatum =
            fn datum

        mappedChildren =
            Dict.map (\key val -> map fn val) children
    in
        (Tree mappedDatum mappedChildren)

-- 
-- {-| Map a Function over a List and a DictTree.
-- -}
-- mapListOverTree : (a -> b -> result) -> List a -> Tree b -> Maybe (Tree result)
-- mapListOverTree fn list (Tree datum children) =
--     case list of
--         [] ->
--             Nothing
-- 
--         head :: [] ->
--             let
--                 mappedDatum =
--                     fn head datum
--             in
--                 Just (Tree mappedDatum Dict.empty)
-- 
--         head :: rest ->
--             let
--                 mappedDatum =
--                     fn head datum
-- 
--                 listGroupedByLengthOfChildren =
--                     splitByLength (List.map length children) rest
-- 
--                 mappedChildren =
--                     List.map2 (\l child -> mapListOverTree fn l child) listGroupedByLengthOfChildren children
--                         |> List.filterMap identity
--             in
--                 Just (Tree mappedDatum mappedChildren)
-- 
-- 
-- splitByLength : List Int -> List a -> List (List a)
-- splitByLength listOflengths list =
--     splitByLength_ listOflengths list []
-- 
-- 
-- splitByLength_ : List Int -> List a -> List (List a) -> List (List a)
-- splitByLength_ listOflengths list accu =
--     case listOflengths of
--         [] ->
--             List.reverse accu
-- 
--         currentLength :: restLengths ->
--             case list of
--                 [] ->
--                     List.reverse accu
-- 
--                 head :: rest ->
--                     splitByLength_ restLengths (List.drop currentLength list) ((List.take currentLength list) :: accu)
-- 
-- 
-- {-| Same as map but the function is also applied to the index of each element (starting at zero).
-- -}
-- indexedMap : (Int -> a -> b) -> Tree comparable -> Maybe (Tree b)
-- indexedMap f tree =
--     mapListOverTree f (List.range 0 (length tree - 1)) tree
-- 

{-| Filter the DictTree. Keep only elements whose datum satisfy the predicate.
-}
filter : (b -> Bool) -> Tree comparable b -> Maybe (Tree comparable b)
filter predicate tree =
    case tree of
        (Tree datum children) ->
            if predicate datum then
                filter_ predicate datum children
            else
                Nothing

may_ : comparable -> Maybe(b) -> Maybe((comparable, b))
may_ k v =
    case v of
        Nothing ->
            Nothing
        Just v ->
            Just (k, v)

filter_ : (b -> Bool) -> b -> Forest comparable b -> Maybe (Tree comparable b)
filter_ predicate datum children =
    let
        subfilter = (\k (Tree datum v) -> predicate datum)
        dict_filter =
                (\(k, v) -> may_ k (filter predicate v))
    in
        Just <| Tree datum <| Dict.fromList <| List.filterMap dict_filter <| Dict.toList children


{-| Filter the DictTree. If the predicate is True for a Child the entire path to the root will be part of the result Tree.
-}
filterWithChildPrecedence : (b -> Bool) -> Tree comparable b -> Maybe (Tree comparable b)
filterWithChildPrecedence predicate (Tree datum children) =
    let
        subfilter = (\k tree acc ->
            case filterWithChildPrecedence predicate tree of
                Just tree_ ->
                    Dict.insert k tree_ acc
                Nothing ->
                    acc
            )
        filtered = Dict.foldl subfilter Dict.empty children
    in
        if Dict.isEmpty filtered then 
            if predicate datum then
                Just (Tree datum Dict.empty)
            else
                Nothing

        else
            Just (Tree datum filtered)


{-| Sort values by a derived property. Does not alter the nesting structure of
    the Tree, that is it does not move Nodes up or down levels.

    All sorting functions get a (key,value) tuple so that they can use any
    or all of the key, the datum, and any subtree attributes they can think of.
    
    (sortBy first -- key
        Tree "aa"
            Dict.fromList([("b", Tree "bb" Dict.empty
            ),( Tree "dd" Dict.empty
            ),( Tree "cc" Dict.empty
            )]))
    == (Tree "aa"
            Dict.fromList([( Tree "bb" Dict.empty
            ),("c", Tree "cc" Dict.empty
            ),("d", Tree "dd" Dict.empty
            )]))
-}
sortBy : ((comparable, Tree comparable a) -> comparable1) -> Tree comparable a -> T.Tree a
sortBy fn (Tree datum children) =
    let
        sortedChildren =
            Dict.toList children |> List.sortBy (\child -> fn child)
                |> List.map (\kv -> second kv |> sortBy fn)
    in
        (T.Tree datum sortedChildren)


{-| Sort values with a custom comparison function like:

    flippedComparison a b =
        case compare a b of
          LT -> GT
          EQ -> EQ
          GT -> LT

    This is also the most general sort function, allowing you
    to define any other.
-}
sortWith : ((comparable, Tree comparable a) -> (comparable, Tree comparable a) -> Order) -> Tree comparable a -> T.Tree a
sortWith comparator (Tree datum children) =
    let
        sortedChildren =
            Dict.toList children |> List.sortWith (\first second -> comparator first second)
                |> List.map (\kv -> second kv |> sortWith comparator)
            -- convert to key+val tuples, sort them, extract values, recurse into children
    in
        (T.Tree datum sortedChildren)

